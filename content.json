{"meta":{"title":"基本资料的博客","subtitle":null,"description":"前端开发者","author":"基本资料","url":"https://blog.keyangyang.xyz"},"pages":[],"posts":[{"title":"JavaScript词法作用域","slug":"JavaScript词法作用域","date":"2017-03-14T03:16:31.000Z","updated":"2018-12-07T06:22:45.006Z","comments":true,"path":"2017/03/14/JavaScript词法作用域/","link":"","permalink":"https://blog.keyangyang.xyz/2017/03/14/JavaScript词法作用域/","excerpt":"","text":"看到一道经典的面试题，关于JavaScript作用域问题。 JavaScript变量作用域函数限定变量作用域在JavaScript中，只有函数可以限定一个变量的作用范围。1234if(true) &#123; var num = 10;&#125;console.log(num); 上面的代码会输出10. 12345678var func = function() &#123; var num = 10;&#125;;try &#123; console.log(num);&#125; catch(e) &#123; console.log(e);&#125; 上面的代码运行时，会抛出一个异常，ReferenceError: num is not defined，即变量num没有定义。也就是说，函数内的变量无法在函数外使用。但是可以在函数内部使用，即使是在赋值之前，如下：12345678910var func = function() &#123; console.log(num); var num = 10; console.log(num);&#125;;try &#123; func();&#125; catch(e) &#123; console.log(e);&#125; 这里会先在控制台先打后印undefined和10。这里会出现undefined牵扯到子域访问父域的问题。 子域访问父域在JavaScript中，只有函数可以限定变量的作用域，那么在函数中的函数就成为该作用域的子域。子域中的代码可以访问到父域中的变量，如下：12345678var func = function() &#123; var num = 10; var sub_func = function() &#123; console.log(num); &#125;; sub_func();&#125;;func(); 执行得到结果10。可以看到上文所说的变量访问情况。但是在子域中访问父域的代码也是有条件的。如下面代码：123456789var func = function() &#123; var num = 10; var sub_func = function() &#123; var num = 20; console(num); &#125;; sub_func();&#125;;func(); 子域中又定义了一个变量var num=20,那么子域会访问当前子域中的变量，不会在访问父域中的变量。 由此可见访问有一定规则可言。 在JavaScript中使用变量，JavaScript解释器首先在当前作用域中搜索是否有该变量的定义，如果有，就是用这个变量；如果没有就到父域中寻找该变量。 以此类推，直到最顶级作用域，仍然没有找到就抛出异常”变量未定义”。看下面代码：123456789(function() &#123; var num = 10; (function() &#123; var num = 20; (function()&#123; console.log(num); &#125;)() &#125;)();&#125;)(); 这段代码执行后打印出20。如果将var num = 20;去掉，那么打印的就是10。 同样，如果再去掉var num = 10，那么就会出现未定义的错误。 链接其它更详细的解释及案例： JavaScript 开发进阶：理解 JavaScript 作用域和作用域链 深入理解JavaScript高级之词法作用域和作用域链","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.keyangyang.xyz/categories/JavaScript/"}],"tags":[]},{"title":"genertaor-jibenziliao-react配置","slug":"genertaor-jibenziliao-react配置","date":"2017-03-09T14:49:30.000Z","updated":"2018-12-07T06:22:44.956Z","comments":true,"path":"2017/03/09/genertaor-jibenziliao-react配置/","link":"","permalink":"https://blog.keyangyang.xyz/2017/03/09/genertaor-jibenziliao-react配置/","excerpt":"","text":"为了方便今后的项目搭建，开始学习搭建自己的yeoman脚手架 genertaor-jibenziliao-react说明npm仓库地址：genertaor-jibenziliao-react github仓库地址：genertaor-jibenziliao-react 介绍页面：genertaor-jibenziliao-react 搭建步骤搭建步骤网上有很多，这里简单说明一下 项目名称一定要以generator-*开头，不然到时候yeoman找不到你的这个脚手架。 新建目录genertaor-jibenziliao-react，执行npm init，创建一个package.json 1234567891011121314151617181920212223242526&#123; &quot;name&quot;: &quot;generator-jibenziliao-react&quot;, &quot;version&quot;: &quot;0.0.7&quot;, &quot;description&quot;: &quot;基于react+webpack2的项目脚手架&quot;, &quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;git+https://github.com/jibenziliao/generator-jibenziliao-react.git&quot; &#125;, &quot;keywords&quot;: [ &quot;yeoman-generator&quot;, &quot;react&quot;, &quot;webpack&quot;, &quot;yeoman&quot; ], &quot;author&quot;: &quot;jibenziliao&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;bugs&quot;: &#123; &quot;url&quot;: &quot;https://github.com/jibenziliao/generator-jibenziliao-react/issues&quot; &#125;, &quot;homepage&quot;: &quot;https://jibenziliao.github.io/generator-jibenziliao-react/&quot;, &quot;dependencies&quot;: &#123; &quot;lodash&quot;: &quot;^4.17.4&quot;, &quot;yeoman-generator&quot;: &quot;^1.1.1&quot;, &quot;date-util&quot;: &quot;^1.2.1&quot; &#125;&#125; package.json中的description字段也是必写的，这是yeoman索引出来项目的简介。 关键词里必须包含yeoman-generator,这样yeoman才能对项目建立索引。 在根目录下新建一个目录generators，最后使用yo初始化的项目的时候，所有的资源文件都是从这个目录下拷贝的。官方还支持另一种目录结构，这里就不做介绍了。感兴趣的可以前往yeoman官网查看完整教程。 package.json中的dependencies必须要有yeoman-generator。 项目的模板文件在generators/app/templates/目录下。 yeoman脚手架有个生成周期的概念： 当执行yo example启动生成器时，它会沿着它的生命周期执行如下特定名称的函数，这些特定名称的函数会放进一个队列里面按顺序执行，如果功能函数不是特定的函数名称，则放进另一个队列default按顺序执行。这些特定的函数名称有: initializing : 初始化阶段 - prompting : 接受用户输入阶段 - configuring : 保存配置信息和文件，如.editorconfig - default : 非特定的功能函数名称，本项目并没有用到 - writing : 生成项目目录结构阶段（从templates目录下拷贝文件到项目中，需要注意配置路径） - conflicts : 统一处理冲突，如要生成的文件已经存在是否覆盖等处理 - install : 安装依赖阶段，如通过npm、bower - end : 生成器即将结束 具体的配置可查看源码","categories":[{"name":"webpack","slug":"webpack","permalink":"https://blog.keyangyang.xyz/categories/webpack/"}],"tags":[]},{"title":"Mac命令行代理","slug":"Mac命令行代理","date":"2017-03-05T13:52:54.000Z","updated":"2018-12-07T06:22:45.056Z","comments":true,"path":"2017/03/05/Mac命令行代理/","link":"","permalink":"https://blog.keyangyang.xyz/2017/03/05/Mac命令行代理/","excerpt":"","text":"问题做开发的朋友肯定经常使用命令行，克隆项目、下载依赖什么的。 虽然npm可以设置淘宝源，但是有些项目在下载依赖时，会从github上下载。如果本机网络环境不好的话，就比较悲剧了，虽然有了Shadowsocks，但也只能代理浏览器之类的，不能让命令行也实现代理。 解决方案经过查找，发现了一个简单的方法，可以单次在当前命令行窗口实现代理。 12export http_proxy=127.0.0.1:1087export https_proxy=127.0.0.1:1087 以上将http https协议代理到本地的8087端口,且只对当前终端窗口有效。如果不需要代理，关掉当前窗口，重开一个就好了。","categories":[{"name":"工具","slug":"工具","permalink":"https://blog.keyangyang.xyz/categories/工具/"}],"tags":[]},{"title":"ESLint配置技巧","slug":"ESLint配置技巧","date":"2017-03-04T15:23:44.000Z","updated":"2018-12-07T06:42:38.872Z","comments":true,"path":"2017/03/04/ESLint配置技巧/","link":"","permalink":"https://blog.keyangyang.xyz/2017/03/04/ESLint配置技巧/","excerpt":"","text":"问题在使用VS Code配置ESLint插件时，发现ESLint语法检查对node环境的一些常量支持的不太好。如图所示 解决办法这里需要用到ESLint的API：Disabling Rules with Inline Comments使用注释的方法，单独禁用某一行代码的语法检查如图所示","categories":[{"name":"工具","slug":"工具","permalink":"https://blog.keyangyang.xyz/categories/工具/"}],"tags":[]},{"title":"HTML5 全局contenteditable属性","slug":"HTML5-全局contenteditable属性","date":"2017-03-04T07:40:39.000Z","updated":"2018-12-07T06:22:44.974Z","comments":true,"path":"2017/03/04/HTML5-全局contenteditable属性/","link":"","permalink":"https://blog.keyangyang.xyz/2017/03/04/HTML5-全局contenteditable属性/","excerpt":"","text":"问题今天无聊在上网时，发现某网站中的多选框中会有光标闪烁。 第一反应是，这个不会是input吧，但input只支持文本，里面的UI元素怎么弄的？ 解决方案后来发现，多选框的div有一个属性：contenteditable 原来这个contenteditable属性是HTML5的新属性。 contenteditable 属性规定是否可编辑元素的内容。","categories":[{"name":"HTML5","slug":"HTML5","permalink":"https://blog.keyangyang.xyz/categories/HTML5/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://blog.keyangyang.xyz/tags/HTML5/"}]},{"title":"随笔","slug":"随笔","date":"2016-12-01T13:51:27.000Z","updated":"2018-12-07T06:22:45.091Z","comments":true,"path":"2016/12/01/随笔/","link":"","permalink":"https://blog.keyangyang.xyz/2016/12/01/随笔/","excerpt":"","text":"测试测试","categories":[],"tags":[]}]}